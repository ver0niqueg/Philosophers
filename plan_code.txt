Philospher = thread
Fork = mutex
Manger - dormir - reflechir
Chaque philosopher a besoin de deux fourchettes pour manger sachant
qu'il y a autant de fourchette que de philosophe.
Aucun philosophe ne doit mourir de faim !!

./philo arg1 arg2 arg3 arg4 arg5
arg1 = number_of_philosophers (also the nb of forks)
arg2 = time_to_die (s'il a pas mange depuis time_to_die millisec il
meurt)
arg3 = time_to_eat (temps pour manger avec 2 fourchettes en milisec)
arg4 = time_to_sleep (temps pour dodo en milisec)
arg5 = number_of_times_each_philosopher_must_eat (nb de fois que
chaque philosophe doit manger, arg optionnel)

Les threads sont des unites d'execution au sein d'un meme processus.
Ils partagent les memes ressources du processus mais chacun execcute
sa propre tache. Cependant, il peut y avoir des pb comme par ex si
deux threads veulent acceder a la meme variable de la memoire
partagee au meme moment. Il faut donc utiliser les mutex qui servent
a verouiller un bout de code, les autres threads vont donc devoir
attendre qu'il soit deverouille pour pouvoir executer ce bout de code.
Chaque fourchette a son propre mutex qui permet de la verouiller
lorsqu'un philosophe la prend. On utilise aussi un mutex partage par
tous les philosophes qui permet de print du texte sans melanger.

STRATEGIE
- Faire partir les philos pairs ou impairs avec du retard. Car si
tous les philosophes commencent en meme temps et prennent leur
fourchette droite personne ne pourra manger.
- Chaque philosophe a sa propre fourchette Ã  gauche (l_f) et
emprunte celle de son voisin a droite grace au pointeur (*r_f) qui
pointe sur la l_f du voisin de droite
- Obligee de checker la mort dans un thread a cote sinon ne se rend
 pas compte a temps si y en a un qui meurt. Mais par contre si le
 thread check en continue la si le philo est mort ca baisse trop
 les perfs. Donc a chaque fois qu'un philo va faire ses activites
 un thread qui check la mort se lance. Et ce thread va
 usleep(time_to_die) et ensuite checker si le philo est mort.

 OUTPUT :
 - Timestamp : shows the time in milliseconds since the simulation
 has started.
 - Philosopher number : indicates which philosopher is taking the action
 - Actions : Includes messages about the action (each one in separate
 line) and it must be display not more than 10ms after the actual time

Key Concepts to Master

    Thread: Each philosopher is represented as a thread, which is a
	lightweight process capable of running independently, enabling
	multiple philosophers to think and eat simultaneously ( at the same
	Time). For example, while Philosopher 1 is thinking, Philosopher 2
	might be eating because they are separate threads running in parallel.
	It is a way to mimic real life. Imagine a dinner party where guests
	can eat or chat. Threads let each philosopher do their own thing
	concurrently.
    Mutexes: are used to prevent multiple threads from accessing a
	shared resource simultaneously to prevent race conditions. In other
	words, When a thread (a philosopher) wants to access a shared resource
	(like a fork), it must first acquire a lock on the resource using a
	mutex. That means only one thread can hold the mutex at a time. If
	one thread holds the lock, any other thread that tries to acquire
	the same lock will be blocked until the first thread releases it.

 FAIRE ROUTINE + MONITORING

 https://medium.com/@denaelgammal/dining-philosophers-problem-42-project-guide-mandatory-part-a20fb8dc530e

 fonction pthread_create pour creer un thread
 int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                          void *(*start_routine) (void *), void *arg);

pthread_create -> used to create a thread
pthread_join -> used to wait for a specific thread to finish its execution
+ ensures that the memory and resources associated with thread are properly freed after they finish their work
pthread_mutex_destroy
pthread_mutex_lock
pthread_mutex_unlock

